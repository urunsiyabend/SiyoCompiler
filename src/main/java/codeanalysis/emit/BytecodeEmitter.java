package codeanalysis.emit;

import codeanalysis.LabelSymbol;
import codeanalysis.VariableSymbol;
import codeanalysis.binding.*;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

import java.util.HashMap;
import java.util.Map;

/**
 * Emits JVM bytecode from a lowered BoundBlockStatement.
 * Generates a single .class file with a static main method.
 *
 * @see <a href="https://github.com/urunsiyabend">GitHub Profile</a>
 * @author Siyabend Urun
 * @version 1.0
 */
public class BytecodeEmitter implements Opcodes {
    private final BoundBlockStatement _root;
    private final String _className;
    private final Map<VariableSymbol, Integer> _locals = new HashMap<>();
    private final Map<LabelSymbol, Label> _labels = new HashMap<>();
    private int _nextLocalSlot = 1; // Slot 0 is reserved for args in main

    /**
     * Creates a new BytecodeEmitter.
     *
     * @param root      The lowered BoundBlockStatement to emit.
     * @param className The name of the generated class.
     */
    public BytecodeEmitter(BoundBlockStatement root, String className) {
        _root = root;
        _className = className;
    }

    /**
     * Emits the bytecode for the program.
     *
     * @return The generated bytecode as a byte array.
     */
    public byte[] emit() {
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);

        // Define the class: public class <className>
        cw.visit(V17, ACC_PUBLIC | ACC_SUPER, _className, null, "java/lang/Object", null);

        // Generate default constructor
        emitConstructor(cw);

        // Generate main method
        emitMainMethod(cw);

        cw.visitEnd();
        return cw.toByteArray();
    }

    /**
     * Emits a default constructor.
     */
    private void emitConstructor(ClassWriter cw) {
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
        mv.visitCode();
        mv.visitVarInsn(ALOAD, 0);
        mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
        mv.visitInsn(RETURN);
        mv.visitMaxs(1, 1);
        mv.visitEnd();
    }

    /**
     * Emits the main method containing the program logic.
     */
    private void emitMainMethod(ClassWriter cw) {
        MethodVisitor mv = cw.visitMethod(
                ACC_PUBLIC | ACC_STATIC,
                "main",
                "([Ljava/lang/String;)V",
                null,
                null
        );
        mv.visitCode();

        // Pre-create all labels
        for (BoundStatement stmt : _root.getStatements()) {
            if (stmt instanceof BoundLabelStatement labelStmt) {
                _labels.put(labelStmt.getLabel(), new Label());
            }
        }

        // Emit all statements
        for (BoundStatement stmt : _root.getStatements()) {
            emitStatement(mv, stmt);
        }

        // Return from main
        mv.visitInsn(RETURN);
        mv.visitMaxs(0, 0); // Computed automatically
        mv.visitEnd();
    }

    /**
     * Emits bytecode for a statement.
     */
    private void emitStatement(MethodVisitor mv, BoundStatement stmt) {
        switch (stmt.getType()) {
            case VariableDeclaration -> emitVariableDeclaration(mv, (BoundVariableDeclaration) stmt);
            case ExpressionStatement -> emitExpressionStatement(mv, (BoundExpressionStatement) stmt);
            case LabelStatement -> emitLabelStatement(mv, (BoundLabelStatement) stmt);
            case GotoStatement -> emitGotoStatement(mv, (BoundGotoStatement) stmt);
            case ConditionalGotoStatement -> emitConditionalGotoStatement(mv, (BoundConditionalGotoStatement) stmt);
            default -> throw new RuntimeException("Unexpected statement type: " + stmt.getType());
        }
    }

    /**
     * Emits bytecode for a variable declaration.
     */
    private void emitVariableDeclaration(MethodVisitor mv, BoundVariableDeclaration decl) {
        VariableSymbol var = decl.getVariable();
        int slot = allocateLocal(var);

        emitExpression(mv, decl.getInitializer());
        emitStore(mv, var, slot);
    }

    /**
     * Emits bytecode for an expression statement.
     */
    private void emitExpressionStatement(MethodVisitor mv, BoundExpressionStatement stmt) {
        emitExpression(mv, stmt.getExpression());
        // Pop the result if the expression leaves a value on the stack
        Class<?> type = stmt.getExpression().getClassType();
        if (type != null && type != Void.class) {
            mv.visitInsn(POP);
        }
    }

    /**
     * Emits bytecode for a label statement.
     */
    private void emitLabelStatement(MethodVisitor mv, BoundLabelStatement stmt) {
        Label label = getOrCreateLabel(stmt.getLabel());
        mv.visitLabel(label);
    }

    /**
     * Emits bytecode for a goto statement.
     */
    private void emitGotoStatement(MethodVisitor mv, BoundGotoStatement stmt) {
        Label label = getOrCreateLabel(stmt.getLabel());
        mv.visitJumpInsn(GOTO, label);
    }

    /**
     * Emits bytecode for a conditional goto statement.
     */
    private void emitConditionalGotoStatement(MethodVisitor mv, BoundConditionalGotoStatement stmt) {
        Label label = getOrCreateLabel(stmt.getLabel());
        emitExpression(mv, stmt.getCondition());

        // Jump based on condition
        if (stmt.getJumpIfTrue()) {
            mv.visitJumpInsn(IFNE, label); // Jump if true (non-zero)
        } else {
            mv.visitJumpInsn(IFEQ, label); // Jump if false (zero)
        }
    }

    /**
     * Emits bytecode for an expression, leaving the result on the stack.
     */
    private void emitExpression(MethodVisitor mv, BoundExpression expr) {
        switch (expr.getType()) {
            case LiteralExpression -> emitLiteralExpression(mv, (BoundLiteralExpression) expr);
            case VariableExpression -> emitVariableExpression(mv, (BoundVariableExpression) expr);
            case AssignmentExpression -> emitAssignmentExpression(mv, (BoundAssignmentExpression) expr);
            case UnaryExpression -> emitUnaryExpression(mv, (BoundUnaryExpression) expr);
            case BinaryExpression -> emitBinaryExpression(mv, (BoundBinaryExpression) expr);
            default -> throw new RuntimeException("Unexpected expression type: " + expr.getType());
        }
    }

    /**
     * Emits bytecode for a literal expression.
     */
    private void emitLiteralExpression(MethodVisitor mv, BoundLiteralExpression expr) {
        Object value = expr.getValue();
        if (value instanceof Integer intValue) {
            emitIntConstant(mv, intValue);
        } else if (value instanceof Boolean boolValue) {
            mv.visitInsn(boolValue ? ICONST_1 : ICONST_0);
        } else {
            throw new RuntimeException("Unsupported literal type: " + value.getClass());
        }
    }

    /**
     * Emits bytecode for a variable expression.
     */
    private void emitVariableExpression(MethodVisitor mv, BoundVariableExpression expr) {
        VariableSymbol var = expr.getVariable();
        int slot = getLocalSlot(var);
        mv.visitVarInsn(ILOAD, slot); // Both int and boolean use ILOAD
    }

    /**
     * Emits bytecode for an assignment expression.
     */
    private void emitAssignmentExpression(MethodVisitor mv, BoundAssignmentExpression expr) {
        VariableSymbol var = expr.getVariable();
        int slot = getLocalSlot(var);

        emitExpression(mv, expr.getExpression());
        mv.visitInsn(DUP); // Keep value on stack (assignment returns the value)
        emitStore(mv, var, slot);
    }

    /**
     * Emits bytecode for a unary expression.
     */
    private void emitUnaryExpression(MethodVisitor mv, BoundUnaryExpression expr) {
        emitExpression(mv, expr.getOperand());

        switch (expr.getOperator().getType()) {
            case Identity -> {
                // No-op, value is already on stack
            }
            case Negation -> mv.visitInsn(INEG);
            case LogicalNegation -> {
                // Boolean NOT: XOR with 1
                mv.visitInsn(ICONST_1);
                mv.visitInsn(IXOR);
            }
            case OnesComplement -> {
                // Bitwise NOT: XOR with -1
                mv.visitInsn(ICONST_M1);
                mv.visitInsn(IXOR);
            }
            default -> throw new RuntimeException("Unexpected unary operator: " + expr.getOperator().getType());
        }
    }

    /**
     * Emits bytecode for a binary expression.
     */
    private void emitBinaryExpression(MethodVisitor mv, BoundBinaryExpression expr) {
        BoundBinaryOperatorType opType = expr.getOperator().getType();

        // Handle short-circuit operators specially
        if (opType == BoundBinaryOperatorType.LogicalAnd) {
            emitLogicalAnd(mv, expr);
            return;
        }
        if (opType == BoundBinaryOperatorType.LogicalOr) {
            emitLogicalOr(mv, expr);
            return;
        }

        // Emit operands
        emitExpression(mv, expr.getLeft());
        emitExpression(mv, expr.getRight());

        switch (opType) {
            case Addition -> mv.visitInsn(IADD);
            case Subtraction -> mv.visitInsn(ISUB);
            case Multiplication -> mv.visitInsn(IMUL);
            case Division -> mv.visitInsn(IDIV);
            case Modulo -> mv.visitInsn(IREM);
            case BitwiseAnd -> mv.visitInsn(IAND);
            case BitwiseOr -> mv.visitInsn(IOR);
            case BitwiseXor -> mv.visitInsn(IXOR);
            case LeftShift -> mv.visitInsn(ISHL);
            case RightShift -> mv.visitInsn(ISHR);
            case Equals -> emitComparison(mv, IF_ICMPEQ);
            case NotEquals -> emitComparison(mv, IF_ICMPNE);
            case LessThan -> emitComparison(mv, IF_ICMPLT);
            case LessOrEqualsThan -> emitComparison(mv, IF_ICMPLE);
            case GreaterThan -> emitComparison(mv, IF_ICMPGT);
            case GreaterOrEqualsThen -> emitComparison(mv, IF_ICMPGE);
            default -> throw new RuntimeException("Unexpected binary operator: " + opType);
        }
    }

    /**
     * Emits bytecode for a comparison operation that leaves 0 or 1 on stack.
     */
    private void emitComparison(MethodVisitor mv, int opcode) {
        Label trueLabel = new Label();
        Label endLabel = new Label();

        mv.visitJumpInsn(opcode, trueLabel);
        mv.visitInsn(ICONST_0);
        mv.visitJumpInsn(GOTO, endLabel);
        mv.visitLabel(trueLabel);
        mv.visitInsn(ICONST_1);
        mv.visitLabel(endLabel);
    }

    /**
     * Emits bytecode for logical AND with short-circuit evaluation.
     */
    private void emitLogicalAnd(MethodVisitor mv, BoundBinaryExpression expr) {
        Label falseLabel = new Label();
        Label endLabel = new Label();

        emitExpression(mv, expr.getLeft());
        mv.visitJumpInsn(IFEQ, falseLabel);

        emitExpression(mv, expr.getRight());
        mv.visitJumpInsn(IFEQ, falseLabel);

        mv.visitInsn(ICONST_1);
        mv.visitJumpInsn(GOTO, endLabel);

        mv.visitLabel(falseLabel);
        mv.visitInsn(ICONST_0);

        mv.visitLabel(endLabel);
    }

    /**
     * Emits bytecode for logical OR with short-circuit evaluation.
     */
    private void emitLogicalOr(MethodVisitor mv, BoundBinaryExpression expr) {
        Label trueLabel = new Label();
        Label endLabel = new Label();

        emitExpression(mv, expr.getLeft());
        mv.visitJumpInsn(IFNE, trueLabel);

        emitExpression(mv, expr.getRight());
        mv.visitJumpInsn(IFNE, trueLabel);

        mv.visitInsn(ICONST_0);
        mv.visitJumpInsn(GOTO, endLabel);

        mv.visitLabel(trueLabel);
        mv.visitInsn(ICONST_1);

        mv.visitLabel(endLabel);
    }

    /**
     * Emits an integer constant using the most efficient instruction.
     */
    private void emitIntConstant(MethodVisitor mv, int value) {
        if (value >= -1 && value <= 5) {
            mv.visitInsn(ICONST_0 + value); // ICONST_M1 to ICONST_5
        } else if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) {
            mv.visitIntInsn(BIPUSH, value);
        } else if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) {
            mv.visitIntInsn(SIPUSH, value);
        } else {
            mv.visitLdcInsn(value);
        }
    }

    /**
     * Emits a store instruction for a variable.
     */
    private void emitStore(MethodVisitor mv, VariableSymbol var, int slot) {
        mv.visitVarInsn(ISTORE, slot); // Both int and boolean use ISTORE
    }

    /**
     * Allocates a local variable slot and returns it.
     */
    private int allocateLocal(VariableSymbol var) {
        int slot = _nextLocalSlot++;
        _locals.put(var, slot);
        return slot;
    }

    /**
     * Gets the local variable slot for a variable.
     */
    private int getLocalSlot(VariableSymbol var) {
        Integer slot = _locals.get(var);
        if (slot == null) {
            throw new RuntimeException("Variable not found: " + var.getName());
        }
        return slot;
    }

    /**
     * Gets or creates a Label for a LabelSymbol.
     */
    private Label getOrCreateLabel(LabelSymbol symbol) {
        return _labels.computeIfAbsent(symbol, k -> new Label());
    }
}
